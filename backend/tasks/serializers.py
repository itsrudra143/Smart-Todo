from rest_framework import serializers
from django.db.models import F
from .models import Task, Category, ContextEntry
from ai_pipeline.service import analyze_context_entry


class CategorySerializer(serializers.ModelSerializer):
    class Meta:
        model = Category
        fields = "__all__"


class TaskSerializer(serializers.ModelSerializer):
    # On read, show full category objects.
    categories = CategorySerializer(many=True, read_only=True)
    # On write, accept a list of category names.
    category_names = serializers.ListField(
        child=serializers.CharField(max_length=100),
        write_only=True,
        required=False,
        help_text="List of category names to associate with the task.",
    )

    class Meta:
        model = Task
        fields = [
            "id",
            "title",
            "description",
            "categories",
            "priority",
            "status",
            "deadline",
            "created_at",
            "updated_at",
            "category_names",
        ]

    def create(self, validated_data):
        category_names = validated_data.pop("category_names", [])
        task = Task.objects.create(**validated_data)

        if category_names:
            categories_to_add = []
            category_pks_to_increment = []
            for name in category_names:
                # Use strip() and lower() to normalize category names
                normalized_name = name.strip().lower()
                category, _ = Category.objects.get_or_create(name=normalized_name)
                categories_to_add.append(category)
                category_pks_to_increment.append(category.pk)

            # Increment usage_count for all added categories in a single query
            Category.objects.filter(pk__in=category_pks_to_increment).update(
                usage_count=F("usage_count") + 1
            )
            task.categories.set(categories_to_add)

        return task

    def update(self, instance, validated_data):
        category_names = validated_data.pop("category_names", None)

        # The attachment is handled by the view/parser, so we let super() handle it
        instance = super().update(instance, validated_data)

        if category_names is not None:
            old_category_pks = set(instance.categories.values_list("pk", flat=True))

            new_categories = []
            new_category_pks = set()
            for name in category_names:
                normalized_name = name.strip().lower()
                category, _ = Category.objects.get_or_create(name=normalized_name)
                new_categories.append(category)
                new_category_pks.add(category.pk)

            pks_to_decrement = old_category_pks - new_category_pks
            pks_to_increment = new_category_pks - old_category_pks

            if pks_to_decrement:
                Category.objects.filter(pk__in=pks_to_decrement).update(
                    usage_count=F("usage_count") - 1
                )

            if pks_to_increment:
                Category.objects.filter(pk__in=pks_to_increment).update(
                    usage_count=F("usage_count") + 1
                )

            instance.categories.set(new_categories)

        return instance


class TaskImportSerializer(serializers.Serializer):
    """Serializer for validating a single task from an import file."""

    title = serializers.CharField(max_length=255)
    description = serializers.CharField(allow_blank=True, required=False, default="")
    status = serializers.ChoiceField(
        choices=Task.Status.choices, default=Task.Status.TODO
    )
    priority = serializers.IntegerField(min_value=1, max_value=5, default=1)
    # Expects a comma-separated string of category names, e.g., "work,project-x"
    categories = serializers.CharField(allow_blank=True, required=False, default="")
    deadline = serializers.DateField(required=False, allow_null=True)

    def validate_status(self, value):
        # Allow case-insensitive status values (e.g., "todo", "In Progress")
        return value.upper().replace(" ", "_")


class ContextEntrySerializer(serializers.ModelSerializer):
    class Meta:
        model = ContextEntry
        fields = "__all__"
        read_only_fields = (
            "insights",
        )  # Ensures insights can only be generated by the server

    def create(self, validated_data):
        # First, create the object without insights
        context_entry = ContextEntry.objects.create(**validated_data)

        # Then, call the AI service to generate and save insights
        try:
            insights = analyze_context_entry(context_entry.content)
            # Only save if there was no error from the AI service
            if "error" not in insights:
                context_entry.insights = insights
                context_entry.save(update_fields=["insights"])
        except Exception as e:
            # We log the error but don't fail the request.
            # The context entry is already saved, which is the main goal.
            print(
                f"Could not generate AI insights for context entry {context_entry.id}: {e}"
            )

        return context_entry
